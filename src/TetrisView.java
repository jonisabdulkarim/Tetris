// code copied from Simon Lucas
// code copied by Udo Kruschwitz
// template code provided by Professor Ian Daly

import javax.swing.*;
import java.awt.*;
import java.util.Random;
import java.util.Timer;
import java.util.TimerTask;
// import all the Colors
import static java.awt.Color.*;

class TetrisView extends JComponent
{
    // declare (and initialise) essential field variables
    private static Color[] colors =
            {black, green, blue, red,
                    yellow, magenta, pink, cyan};
    private char[] shapes = {'O', 'I', 'L', 'S', 'T', 'U', 'Z'};
    private int[][] a;
    private int w, h; //width and height of grid
    private static int size = 30;
    private boolean game_going = true;
    private static char q = 'N';
    private Square[] squares;
    private Random random = new Random();
    private int score = 0;
    private String endMessage = "";
    private int color;

    TetrisView(int[][] a)
    {
        this.a = a;
        w = a.length;
        h = a[0].length;
        addMouseListener(new MouseHandler(this, 1));
    }

    // this method uses a switch case to allow random shapes to be loaded into the
    // grid as well as allowing the shapes to move around and re-spawn when it reaches
    // the end of the grid or collides with another object.
    // case E is activated when the object reaches the
    // top of the grid and ends the game
    private void nextMove(){
        switch(q) {
            case 'N': //initialises new shapes
                squares = new Square[4];
                q = 'O';
                break;

            case 'X':
                if(squares[0].gameOver(a)){
                    q = 'E';
                }
                else {
                    generateShape();
                }
                break;

            case 'O':
                OBlock.createBlock(squares);
                q = 'W';
                break;

            case 'I':
                IBlock.createBlock(squares);
                q = 'W';
                break;

            case 'L':
                LBlock.createBlock(squares);
                q = 'W';
                break;

            case 'S':
                SBlock.createBlock(squares);
                q = 'W';
                break;

            case 'T':
                TBlock.createBlock(squares);
                q = 'W';
                break;

            case 'U':
                ReverseLBlock.createBlock(squares);
                q = 'W';
                break;

            case 'Z':
                ZBlock.createBlock(squares);
                q = 'W';
                break;

            case 'W':
                if(squares[0].getDown(squares, a, color, this)) {
                    q = 'X';
                }
                break;

            case 'E':
                endMessage = "GAME OVER!";
                game_going = false;
                break;
        }
    }

    // allow different shapes to be generated by randomising the possible
    // switch cases in nextMove()
    private void generateShape(){
        int temp = random.nextInt(shapes.length);
        q = shapes[temp];
        color = random.nextInt(8-1)+1;
    }


    Square[] getSquares(){
        return squares;
    }

    int[][] getFrame(){
        return a;
    }

    void setScore(int num){ score = score + num; }

    // paints grid and shapes as well as game messages
    // code provided by Professor Ian Daly
    public void paintComponent(Graphics g)
    {
        for (int i = 0; i < w; i++)
        {
            for (int j = 0; j < h; j++)
            {
                g.setColor(colors[a[i][j]]);
                g.fill3DRect(i * size, j * size,
                        size, size, true);
            }
        }

        // sets end message and score tally
        g.setColor(RED);
        g.drawString("Score:" + score, 5, 15);
        g.drawString(endMessage, 200, 15);
    }

    // code provided by Professor Ian Daly
    void startTimer()
    {
        Timer timer = new Timer();
        TimerTask task = new TimerTask()
        {
            public void run()
            {
                if (game_going)
                {
                    nextMove();
                    repaint();
                }
            }
        };
        int TIME_INTERVAL = 250;
        timer.scheduleAtFixedRate(task, 0, TIME_INTERVAL);
    }

    public Dimension getPreferredSize() {
        return new Dimension(w * size, h * size);
    }
}
